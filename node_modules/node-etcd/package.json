{
  "name": "node-etcd",
  "version": "2.1.4",
  "description": "etcd library for node.js (etcd v2 api)",
  "licenses": [
    {
      "type": "BSD 3-Clause",
      "url": "http://opensource.org/licenses/BSD-3-Clause"
    }
  ],
  "maintainers": [
    {
      "name": "Stian Eikeland",
      "email": "stian@eikeland.se",
      "url": "http://eikeland.se/"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/stianeikeland/node-etcd.git"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "main": "lib/index.js",
  "scripts": {
    "build": "node_modules/coffee-script/bin/coffee --bare --compile --output lib/ src/*.coffee",
    "prepublish": "node_modules/coffee-script/bin/coffee --bare --compile --output lib/ src/*.coffee",
    "postpublish": "rm -rf lib",
    "test": "node_modules/mocha/bin/mocha --compilers coffee:coffee-script",
    "watch": "node_modules/mocha/bin/mocha --compilers coffee:coffee-script --watch"
  },
  "dependencies": {
    "underscore": "~1.5.2",
    "request": "~2.33.0"
  },
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "mocha": "~1.17.1",
    "should": "~3.1.2",
    "nock": "~0.27.2"
  },
  "keywords": [
    "etcd",
    "raft"
  ],
  "readme": "# node-etcd\n\nA nodejs library for [etcd](http://github.com/coreos/etcd), written in coffee-script.\n\n[![NPM](https://nodei.co/npm/node-etcd.png?downloads=true&stars=true)](https://nodei.co/npm/node-etcd/)\n\nTravis-CI: [![Build Status](https://travis-ci.org/stianeikeland/node-etcd.png?branch=master)](https://travis-ci.org/stianeikeland/node-etcd)\n\n## Install\n\n```\n$ npm install node-etcd\n```\n\nFor the older etcd v1 api, please use the 0.6.x branch\n\n```\n# Older version for v1 API:\n$ npm install node-etcd@0.6.1\n```\n\n## Changes\n\n- 2.1.4 - Don't wait before reconnecting if Etcd server times out our watcher.\n- 2.1.3 - Etcd sends an empty response on timeout in recent versions. Parsing\n  the empty message caused watcher to emit error. Now it reconnects instead.\n- 2.1.2 - Exponential backoff (retry), fix spinning reconnect on error. (@ptte)\n- 2.1.1 - Increase request pool.maxSockets to 100\n- 2.1.0 - Use proper error objects instead of strings for errors.\n- 2.0.10 - Fix error in documentation\n- 2.0.9 - Added .post() alias of .create(). Added .compareAndDelete() (for etcd v0.3.0)\n- 2.0.8 - Watchers can be canceled. In-order keys using #create(). Raw requests using #raw().\n- 2.0.7 - Avoid calling callback if callback not given.\n- 2.0.6 - Refactoring, fix responsehandler error.\n- 2.0.5 - Undo use of 'x-etcd-index', this refers to global state.\n- 2.0.4 - Use 'x-etcd-index' for index when watching a key.\n- 2.0.3 - Watcher supports options. Watcher emits etcd action type.\n- 2.0.2 - Mkdir and rmdir. Fix watcher for v2 api.\n- 2.0.1 - Watch, delete and stats now use new v2 api. Added testAndSet convenience method.\n- 2.0.0 - Basic support for etcd protocol v2. set, get, del now supports options.\n- 0.6.1 - Fixes issue #10, missing response caused error when server connection failed / server responded incorrectly.\n- 0.6.0 - Watcher now emits 'error' on invalid responses.\n\n## Basic usage\n\n```javascript\nEtcd = require('node-etcd');\netcd = new Etcd();\netcd.set(\"key\", \"value\");\netcd.get(\"key\", console.log);\n```\n\n## Methods\n\n### Etcd([host = '127.0.0.1'], [port = '4001'], [ssloptions])\n\nCreate a new etcd client\n\n```javascript\netcd = new Etcd();\netcd = new Etcd('127.0.0.1', '4001');\n```\n\n### .set(key, value = null, [options], [callback])\n\nSet key to value, or create key/directory.\n\n```javascript\netcd.set(\"key\");\netcd.set(\"key\", \"value\");\netcd.set(\"key\", \"value\", console.log);\netcd.set(\"key\", \"value\", { ttl: 60 }, console.log);\n```\n\nAvailable options include:\n\n- `ttl` (time to live in seconds)\n- `prevValue` (previous value, for compare and swap)\n- `prevExist` (existance test, for compare and swap)\n- `prevIndex` (previous index, for compare and swap)\n\nWill create a directory when used without value (value=null): `etcd.set(\"directory/\");`\n\n### .compareAndSwap(key, value, oldvalue, [options], [callback])\n\nConvenience method for test and set (set with {prevValue: oldvalue})\n\n```javascript\netcd.compareAndSwap(\"key\", \"newvalue\", \"oldvalue\");\netcd.compareAndSwap(\"key\", \"newValue\", \"oldValue\", options, console.log);\n```\n\nAlias: `.testAndSet()`\n\n### .get(key, [options], [callback])\n\nGet a key or path.\n\n```javascript\netcd.get(\"key\", console.log);\netcd.get(\"key\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, list all values in directory recursively)\n- `wait` (bool, wait for changes to key)\n- `waitIndex` (wait for changes after given index)\n\n### .del(key, [options], [callback])\n\nDelete a key or path\n\n```javascript\netcd.del(\"key\");\netcd.del(\"key\", console.log);\netcd.del(\"key/\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, delete recursively)\n\nAlias: `.delete()`\n\n### .compareAndDelete(key, oldvalue, [options], [callback])\n\nConvenience method for test and delete (delete with {prevValue: oldvalue})\n\n```javascript\netcd.compareAndDelete(\"key\", \"oldvalue\");\netcd.compareAndDelete(\"key\", \"oldValue\", options, console.log);\n```\n\nAlias: `.testAndDelete()`\n\n### .mkdir(dir, [options], [callback])\n\nCreate a directory\n\n```javascript\netcd.mkdir(\"dir\");\netcd.mkdir(\"dir\", console.log);\netcd.mkdir(\"dir/\", options, console.log);\n```\n\n### .rmdir(dir, [options], [callback])\n\nRemove a directory\n\n```javascript\netcd.rmdir(\"dir\");\netcd.rmdir(\"dir\", console.log);\netcd.rmdir(\"dir/\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, delete recursively)\n\n### .create(path, value, [options], [callback])\n\nAtomically create in-order keys.\n\n```javascript\netcd.create(\"queue\", \"first\")\netcd.create(\"queue\", \"next\", console.log)\n```\n\nAlias: `.post()`\n\n### .watch(key, [options], [callback])\n\nThis is a convenience method for get with `{wait: true}`.\n\n```javascript\netcd.watch(\"key\");\netcd.watch(\"key\", console.log);\n```\n\n### .watchIndex(key, index, [options], callback)\n\nThis is a convenience method for get with `{wait: true, waitIndex: index}`.\n\n```javascript\netcd.watchIndex(\"key\", 7, console.log);\n```\n\n### .watcher(key, [index], [options])\n\nReturns an eventemitter for watching for changes on a key\n\n```javascript\nwatcher = etcd.watcher(\"key\");\nwatcher.on(\"change\", console.log);\nwatcher2 = etcd.watcher(\"key\", null, {recursive: true});\nwatcher2.on(\"error\", console.log);\n```\n\nYou can cancel a watcher by calling `.stop()`.\n\nSignals:\n- `change` - emitted on value change\n- `reconnect` - emitted on reconnect\n- `error` - emitted on invalid content\n- `<etcd action>` - the etcd action that triggered the watcher (ex: set, delete).\n- `stop` - watcher was canceled.\n\n### .raw(method, key, value, options, callback)\n\nBypass the API and do raw queries.\nMethod must be one of: PUT, GET, POST, PATCH, DELETE\n\n```javascript\netcd.raw(\"GET\", \"v2/stats/leader\", null, {}, callback)\netcd.raw(\"PUT\", \"v2/keys/key\", \"value\", {}, callback)\n```\n\nRemember to provide the full path, without any leading '/'\n\n### .machines(callback)\n\nReturns information about etcd nodes in the cluster\n\n```javascript\netcd.machines(console.log);\n```\n\n### .leader(callback)\n\nReturn the leader in the cluster\n\n```javascript\netcd.leader(console.log);\n```\n\n### .leaderStats(callback)\n\nReturn statistics about cluster leader\n\n```javascript\netcd.leaderStats(console.log);\n```\n\n### .selfStats(callback)\n\nReturn statistics about connected etcd node\n\n```javascript\netcd.selfStats(console.log);\n```\n\n## SSL support\n\nPass etcdclient a dictionary containing ssl options, check out http://nodejs.org/api/https.html#https_https_request_options_callback\n\n```javascript\nfs = require('fs');\n\nsslopts = {\n\tca: [ fs.readFileSync('ca.pem') ],\n\tcert: fs.readFileSync('cert.pem'),\n\tkey: fs.readFileSync('key.pem')\n};\n\netcdssl = new Etcd('localhost', '4001', sslopts);\n```\n\n## FAQ:\n\n- Are there any order of execution guarantees when doing multiple requests without using callbacks?\n    - No, order of execution is up to NodeJS and the network. Requests run from a connection pool, meaning that if one request is delayed for some reason they'll arrive at the server out of order. Use callbacks (and maybe even a nice [async](https://github.com/caolan/async) callback handling library for convenient syntax) if ordering is important to prevent race conditions.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/stianeikeland/node-etcd/issues"
  },
  "homepage": "https://github.com/stianeikeland/node-etcd",
  "_id": "node-etcd@2.1.4",
  "_from": "node-etcd@~2.1.4"
}
